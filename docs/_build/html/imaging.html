
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Imaging &#8212; tttrlib  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Analyzing CLSM marker (Leica SP8)" href="imaging_analyzing_clsm_marker_leica_sp8.html" />
    <link rel="prev" title="Single Molecule" href="single_molecule.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="imaging">
<h1>Imaging<a class="headerlink" href="#imaging" title="Permalink to this headline">¶</a></h1>
<div class="section" id="confocal-laser-scanning">
<h2>Confocal laser scanning<a class="headerlink" href="#confocal-laser-scanning" title="Permalink to this headline">¶</a></h2>
<div class="section" id="theory">
<h3>Theory<a class="headerlink" href="#theory" title="Permalink to this headline">¶</a></h3>
<p>In confocal microscopy the laser beam scans over the sample either by moving the sample over a parked (fixed) laser
beam (stage scanning) or by deflecting the laser and moving the position of the exciting on a fixed sample (laser
scanning). In both cases, the position of the detection volume within the sample needs to be saved in the recorded
TTTR event stream.</p>
<p>The position of the laser in the TTTR event stream is encoded by injecting markers into the event stream the report
on the laser position. Some manufactures present these markers as special “”events”” that are distinguished from
normal photon events. Some manufacturers use the same routing channel numbers for markers and for photon detection
channels. To distinguish photons from markers,``TTTR`` objects present for every event an additional event type
specifier (see <span class="xref std std-ref">TTTR Objects:Anatomy</span>).</p>
<p>The position of the laser on the sample is mostly defined by the following markers</p>
<blockquote class="highlights">
<div><ol class="arabic simple">
<li>A frame marker</li>
<li>A line start marker</li>
<li>A line stop marker</li>
</ol>
</div></blockquote>
<p>The line start and the line stop marker define a <em>valid</em> region of the image. In confocal laser scanning microscopy
(CLSM) the laser beam is usually repositioned between the line stop and the line start marker. The detectors are
usually switched on in this period and register how the laser is fast repositioned on the sample.</p>
<p>The assignment of the markers to channels depends on the configuration of the microscope. Below it is briefly outlined
how these markers can be assigned to channels.</p>
<p>Below a typical traces of channel numbers for special events are shown.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tttrlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="kn">as</span> <span class="nn">p</span>

<span class="n">events</span> <span class="o">=</span> <span class="n">tttrlib</span><span class="o">.</span><span class="n">TTTR</span><span class="p">(</span><span class="s1">&#39;../../examples/PQ/HT3/PQ_HT3_CLSM.ht3&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># select special events</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event_type</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_routing_channel</span><span class="p">()</span>

<span class="n">special_events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">e</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">special_events</span><span class="p">][:</span><span class="mi">7000</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">special_events</span><span class="p">][:</span><span class="mi">50</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">special_events</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">special_events</span><span class="p">])</span><span class="o">-</span><span class="mi">200</span><span class="p">:],</span> <span class="s1">&#39;g&#39;</span><span class="p">)</span>


<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="./plots/imaging_special_markers.py">Source code</a>, <a class="reference external" href="./plots/imaging_special_markers.png">png</a>, <a class="reference external" href="./plots/imaging_special_markers.hires.png">hires.png</a>, <a class="reference external" href="./plots/imaging_special_markers.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/imaging_special_markers.png" src="_images/imaging_special_markers.png" />
</div>
<p>To the top a longer trace of special events channel numbers is shown. As can be seen by inspecting the traces of
special events, channel number 4 is followed by an interleaved sequence of channel number 1 and channel number 2.
This identifies channel 4 as frame number and channel 1 and 2 as, line start and line stop, respectively. As is shown
for the end of the special event channel trace, the last frame marker is followed by an incomplete frame. This is
not uncommon. Hence, the photons registered following the last frame number should be rejected, as they would result
in an incomplete image.</p>
<div class="section" id="image-construction">
<h4>Image construction<a class="headerlink" href="#image-construction" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">tttrlib</span></code> provides a set of functions to create images based on CLSM TTTR data. <code class="docutils literal notranslate"><span class="pre">tttrlib</span></code> provides efficient
functionality to generate FLIM images implemented in C/C++. Below, it is outlined, how an image can be only using the
basic functionality of <code class="docutils literal notranslate"><span class="pre">tttrlib</span></code>. The presented outline presented below may serve to understand how the image
construction in CLSM work and is not intended for productive use.</p>
<p>Before creating an image the channel numbers of the frame and the line markers need to be determined. For the example
that is shown above the frame, line start, and line stop markers are 4, 1, and 2, respectively. Next, the TTTR data
needs to be loaded into memory, the number of frames, and the number of lines need to be determined in order to allocate
memory for the image. In CLSM the number of pixels per line can be arbitrarily defined, as the laser beam is
continuously displaced and the fluorescence of the sample is continuously recorded. Hence, the main experimental
determinants of the image size in memory are the number of frames and the number of line scans per frame. Usually,
the number of line scans per frame is constant within a TTTR file.</p>
<p>The number of frames can be determined by counting extracting and counting the number of frame markers as shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">tttrlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="kn">as</span> <span class="nn">p</span>

<span class="k">def</span> <span class="nf">count_marker</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">event_types</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">event_type</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ci</span> <span class="o">==</span> <span class="n">marker</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">event_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">event_type</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">find_marker</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="n">event_types</span><span class="p">,</span> <span class="n">maker</span><span class="p">,</span> <span class="n">event_type</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ci</span> <span class="o">==</span> <span class="n">maker</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">event_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">event_type</span><span class="p">):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="n">events</span> <span class="o">=</span> <span class="n">tttrlib</span><span class="o">.</span><span class="n">TTTR</span><span class="p">(</span><span class="s1">&#39;./examples/PQ/HT3/PQ_HT3_CLSM.ht3&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_event_type</span><span class="p">()</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_routing_channel</span><span class="p">()</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_macro_time</span><span class="p">()</span>
<span class="n">m</span> <span class="o">=</span> <span class="n">events</span><span class="o">.</span><span class="n">get_micro_time</span><span class="p">()</span>

<span class="n">frame_marker_list</span> <span class="o">=</span> <span class="n">find_marker</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="n">line_start_marker_list</span> <span class="o">=</span> <span class="n">find_marker</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">line_stop_marker_list</span> <span class="o">=</span> <span class="n">initialize</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">n_frames</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame_marker_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="c1"># 41</span>
<span class="n">n_line_start_marker</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_start_marker_list</span><span class="p">)</span> <span class="c1"># 10246</span>
<span class="n">n_lines_per_frame</span> <span class="o">=</span> <span class="n">n_line_start_marker</span> <span class="o">/</span> <span class="n">n_frames</span> <span class="c1"># 256</span>
<span class="n">line_duration_valid</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">line_stop_marker_list</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">line_start_marker_list</span><span class="p">]</span>
<span class="n">line_duration_total</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">line_start_marker_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">line_start_marker_list</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">n_pixel</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">pixel_duration</span> <span class="o">=</span> <span class="n">line_duration_valid</span> <span class="o">//</span> <span class="n">n_pixel</span>
<span class="n">line_duration_valid</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">line_stop_marker_list</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">line_start_marker_list</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The channel number of the frame makers (here 4) depends on the experimental setup. Moreover, some
setup configurations use “photons” event types to record special events.</p>
</div>
<p>In the example above, first the number of frames are counted. Next, the number of start line events are counted. In
the example, there are overall 41 frames are present in the file each having 256 lines. As the last frame is often
incomplete (see Figure above) the last frame is neglected (41 - 1 = 40). With the script above, the number of frames
<code class="docutils literal notranslate"><span class="pre">n_frames</span></code> and the number of lines per frame <code class="docutils literal notranslate"><span class="pre">n_lines_per_frame</span></code> is determined. Next, the number of pixel per line
<code class="docutils literal notranslate"><span class="pre">n_pixel</span></code> can be freely defined. Based on the time the laser spends in each line, the duration per pixel (the laser
is constantly scanning) needs to be calculated. Here, there are two options: 1) either the total time from the
beginning of each new line (line start) to the beginning of the next line is considered as a line or 2) the time
between the line start and the line stop is considered as the time base to calculate the pixel duration. In the first
case, the back movement of the laser to the line start can be visualized in the image. In the later case, only the
<em>valid</em> region where the laser scans over the sample is visualized. For most applications the later approach is
useful. To understand the microscope laser scanner the former approach is more useful. Above, <code class="docutils literal notranslate"><span class="pre">line_duration_valid</span></code> is
the time the laser spends in every of the lines in a valid region and <code class="docutils literal notranslate"><span class="pre">line_duration_total</span></code> is the total time the laser
spends in a line including the rewind to the line beginning. Above, <code class="docutils literal notranslate"><span class="pre">n_pixel</span></code> is the freely defined number of pixels
per line and <code class="docutils literal notranslate"><span class="pre">pixel_duration</span></code> is the duration of every pixel. With the number of frames <code class="docutils literal notranslate"><span class="pre">n_frames</span></code>, the number
of pixels <code class="docutils literal notranslate"><span class="pre">n_pixel</span></code>, and the number of lines <code class="docutils literal notranslate"><span class="pre">n_lines_per_frame</span></code> it is clear how much the memory for an image needs to be
can be allocated and with the defined number of pixels per line the duration for the pixel can be calculated for all
the lines of the frames.</p>
<p>With these numbers an image for a certain set of detector channels <code class="docutils literal notranslate"><span class="pre">detector_channels</span></code> can be calculated. Below this
is by the function <code class="docutils literal notranslate"><span class="pre">make_image</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_image</span><span class="p">(</span>
        <span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span>
        <span class="n">n_frames</span><span class="p">,</span> <span class="n">n_lines_per_frame</span><span class="p">,</span> <span class="n">pixel_duration</span><span class="p">,</span>
        <span class="n">channels</span><span class="p">,</span>
        <span class="n">frame_marker</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">stop</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">n_pixel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
        <span class="n">tac_coarsening</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span>
        <span class="n">n_tac_max</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n_pixel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">n_pixel</span> <span class="o">=</span> <span class="n">n_lines_per_frame</span>  <span class="c1"># assume squared image</span>

    <span class="n">n_tac</span> <span class="o">=</span> <span class="n">n_tac_max</span> <span class="o">/</span> <span class="n">tac_coarsening</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_frames</span><span class="p">,</span> <span class="n">n_lines_per_frame</span><span class="p">,</span> <span class="n">n_pixel</span><span class="p">,</span> <span class="n">n_tac</span><span class="p">))</span>
    <span class="c1"># iterate through all photons in a line and add to image</span>

    <span class="n">frame</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">current_line</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">time_start_line</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">invalid_range</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="n">mask_invalid</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">ci</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ti</span><span class="p">,</span> <span class="n">ei</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ei</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># marker</span>
            <span class="k">if</span> <span class="n">ci</span> <span class="o">==</span> <span class="n">frame_marker</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">current_line</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">frame</span> <span class="o">&lt;</span> <span class="n">n_frames</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">elif</span> <span class="n">ci</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">time_start_line</span> <span class="o">=</span> <span class="n">ti</span>
                <span class="n">invalid_range</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">ci</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
                <span class="n">invalid_range</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">current_line</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">ei</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># photon</span>
            <span class="k">if</span> <span class="n">ci</span> <span class="ow">in</span> <span class="n">channels</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">invalid_range</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">mask_invalid</span><span class="p">):</span>
                <span class="n">pixel</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">ti</span> <span class="o">-</span> <span class="n">time_start_line</span><span class="p">)</span> <span class="o">//</span> <span class="n">pixel_duration</span><span class="p">[</span><span class="n">current_line</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">pixel</span> <span class="o">&lt;</span> <span class="n">n_pixel</span><span class="p">:</span>
                    <span class="n">tac</span> <span class="o">=</span> <span class="n">mi</span> <span class="o">/</span> <span class="n">tac_coarsening</span>
                    <span class="n">image</span><span class="p">[</span><span class="n">frame</span><span class="p">,</span> <span class="n">current_line</span><span class="p">,</span> <span class="n">pixel</span><span class="p">,</span> <span class="n">tac</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">image</span>

<span class="n">image</span> <span class="o">=</span> <span class="n">make_image</span><span class="p">(</span>
    <span class="n">c</span><span class="p">,</span>
    <span class="n">m</span><span class="p">,</span>
    <span class="n">t</span><span class="p">,</span>
    <span class="n">e</span><span class="p">,</span>
    <span class="n">n_frames</span><span class="p">,</span>
    <span class="n">n_lines_per_frame</span><span class="p">,</span>
    <span class="n">pixel_duration</span><span class="p">,</span>
    <span class="n">channels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="p">)</span>
</pre></div>
</div>
<p>In the example function <code class="docutils literal notranslate"><span class="pre">make_image</span></code> the an 3D array is created that contains in every pixel a histogram of the
micro times. An histogram of the micro time can be displayed by the code shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;inferno&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="mi">175</span><span class="p">,</span><span class="mi">128</span><span class="p">])</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The outcome of such analysis for a complete working example is shown below including all necessary source code.</p>
<p>(<a class="reference external" href="./plots/imaging_tutorial.py">Source code</a>, <a class="reference external" href="./plots/imaging_tutorial.png">png</a>, <a class="reference external" href="./plots/imaging_tutorial.hires.png">hires.png</a>, <a class="reference external" href="./plots/imaging_tutorial.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/imaging_tutorial.png" src="_images/imaging_tutorial.png" />
</div>
<p>For any practical applications it is recommended the determine the images using the built-in functions of <code class="docutils literal notranslate"><span class="pre">tttrlib</span></code>.
Using this functions is illustrated below.</p>
</div>
<div class="section" id="c-c-interface">
<h4>C/C++ interface<a class="headerlink" href="#c-c-interface" title="Permalink to this headline">¶</a></h4>
<p>As was pointed out above based on some lines of Python source code (see <span class="xref std std-ref">Imaging:Confocal laser scanning:Image construction:Theory</span>)
to construct an image</p>
<blockquote>
<div><ol class="arabic simple">
<li>the frame marker</li>
<li>the line start marker</li>
<li>the line stop marker</li>
<li>the detector channel numbers</li>
<li>the number of pixels per scanning line</li>
</ol>
</div></blockquote>
<p>need to be specified. Based on these parameters, the indices of the photons in the TTTR data stream are assigned to
frames, lines, and pixels. When creating a <code class="docutils literal notranslate"><span class="pre">CLSMImage</span></code> object with a <code class="docutils literal notranslate"><span class="pre">TTTR</span></code> object that contains the photon stream
a set of <code class="docutils literal notranslate"><span class="pre">CLSMFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">CLSMLine</span></code>, and <code class="docutils literal notranslate"><span class="pre">CLSMPixel</span></code> objects are create.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">tttrlib</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pylab</span> <span class="kn">as</span> <span class="nn">p</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">tttrlib</span><span class="o">.</span><span class="n">TTTR</span><span class="p">(</span><span class="s1">&#39;./examples/PQ/HT3/PQ_HT3_CLSM.ht3&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">frame_marker</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">line_start_marker</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">line_stop_marker</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">event_type_marker</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">pixel_per_line</span> <span class="o">=</span> <span class="mi">256</span>
<span class="n">image</span> <span class="o">=</span> <span class="n">tttrlib</span><span class="o">.</span><span class="n">CLSMImage</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                          <span class="n">frame_marker</span><span class="p">,</span>
                          <span class="n">line_start_marker</span><span class="p">,</span>
                          <span class="n">line_stop_marker</span><span class="p">,</span>
                          <span class="n">event_type_marker</span><span class="p">,</span>
                          <span class="n">pixel_per_line</span><span class="p">)</span>
</pre></div>
</div>
<p>As illustrated by the code shown below, every <code class="docutils literal notranslate"><span class="pre">CLSMImage</span></code> object may contain multiple <code class="docutils literal notranslate"><span class="pre">CLSMFrame</span></code> objects , every
<code class="docutils literal notranslate"><span class="pre">CLSMFrame</span></code> contain a set of <code class="docutils literal notranslate"><span class="pre">CLSMLine</span></code> objects, and every <code class="docutils literal notranslate"><span class="pre">CLSMLine</span></code> object contains multiple <code class="docutils literal notranslate"><span class="pre">CLSMPixel</span></code>
objects. The number of <code class="docutils literal notranslate"><span class="pre">CLSMPixel</span></code> objects per line is specified upon instantiation if the <code class="docutils literal notranslate"><span class="pre">CLSMImage</span></code> object (see
code example above). The <code class="docutils literal notranslate"><span class="pre">CLSMFrame</span></code>, <code class="docutils literal notranslate"><span class="pre">CLSMLine</span></code>, and the <code class="docutils literal notranslate"><span class="pre">CLSMPixel</span></code> classes derive from the <code class="docutils literal notranslate"><span class="pre">TTTRRange</span></code> class
and provide access to the associated TTTR indices that mark the beginning and the end of the respective object via the
function <code class="docutils literal notranslate"><span class="pre">get_start_stop</span></code> (see example below).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">frames</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">get_frames</span><span class="p">()</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Frame&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;-----&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start, stop: &quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">get_start_stop</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start time, stop time: &quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">get_start_stop_time</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;duration: &quot;</span><span class="p">,</span> <span class="n">frame</span><span class="o">.</span><span class="n">get_duration</span><span class="p">())</span>

<span class="n">lines</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">get_lines</span><span class="p">()</span>
<span class="n">line</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Line&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;-----&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start, stop: &quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">get_start_stop</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start time, stop time: &quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">get_start_stop_time</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;duration: &quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">.</span><span class="n">get_duration</span><span class="p">())</span>

<span class="n">pixels</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_pixels</span><span class="p">()</span>
<span class="n">pixel</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Pixel&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;-----&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start, stop: &quot;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">.</span><span class="n">get_start_stop</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start time, stop time: &quot;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">.</span><span class="n">get_start_stop_time</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;duration: &quot;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">.</span><span class="n">get_duration</span><span class="p">())</span>
</pre></div>
</div>
<p>Object of the <code class="docutils literal notranslate"><span class="pre">CLSMImage</span></code> class store the frame, line, and pixel location of the TTTR data stream that was used to
create the <code class="docutils literal notranslate"><span class="pre">CLSMImage</span></code> object. Next, to determine images, the detection channels of interest need to be specified
using the method <code class="docutils literal notranslate"><span class="pre">fill_pixels</span></code>. The method <code class="docutils literal notranslate"><span class="pre">fill_pixels</span></code> populates the</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The pixels are not filled with start and stop indices and associated start and stop times, as the channels of
the image have not been defined.</p>
</div>
<p>To fill the pixels, it has to be defined, which detection channels are used. Next, the pixels can be filled. When
filling the pixels, to every pixel a start and stop time in the TTTR data stream is associated.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">channels</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">image</span><span class="o">.</span><span class="n">fill_pixels</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s2">&quot;Pixel&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;-----&quot;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start, stop: &quot;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">.</span><span class="n">get_start_stop</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;start time, stop time: &quot;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">.</span><span class="n">get_start_stop_time</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="s2">&quot;duration: &quot;</span><span class="p">,</span> <span class="n">pixel</span><span class="o">.</span><span class="n">get_start_stop_time</span><span class="p">())</span>

<span class="n">image_intensity</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">get_intensity_image</span><span class="p">()</span>
<span class="n">image_decay</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">get_decay_image</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>

<span class="n">p</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image_intensity</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">p</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">image_decay</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
<span class="n">p</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>To yield the mean time between excitation and detection of fluorescence the method <code class="docutils literal notranslate"><span class="pre">get_mean_tac_image</span></code> can be used.
The example shown below shows the counts per pixel for all frames (top, left), the counts per pixel for frame number 30
(top, right), and the mean time between excitation and detection of fluorescence (bottom, left). The function
<code class="docutils literal notranslate"><span class="pre">get_mean_tac_image</span></code> takes in addition to the TTTR data an argument that discriminates pixels with less than a
certain amount of photons (below 3 photons). As can be seen by this analysis, the mean time between excitation and
detection of fluorescence is fairly constant over the cell, while the intensity varies in this particular sample.</p>
<p>For more detailed analysis the fluorescence decays contained in the 4D image (frame, x, y, fluorescence decay) returned
by <code class="docutils literal notranslate"><span class="pre">get_decay_image</span></code> can be used, e.g., by analyzing fluorescence decay histograms. The fluorescence decay containing
all photons of frame 30 is shown to the bottom right.</p>
<p>(<a class="reference external" href="./plots/imaging_tutorial_2.py">Source code</a>, <a class="reference external" href="./plots/imaging_tutorial_2.png">png</a>, <a class="reference external" href="./plots/imaging_tutorial_2.hires.png">hires.png</a>, <a class="reference external" href="./plots/imaging_tutorial_2.pdf">pdf</a>)</p>
<div class="figure">
<img alt="_images/imaging_tutorial_2.png" src="_images/imaging_tutorial_2.png" />
</div>
</div>
</div>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">tttrlib</a></h1>








<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tttr_objects.html">Anatomy</a></li>
<li class="toctree-l1"><a class="reference internal" href="tttr_objects.html#create-tttr-objects">Create TTTR objects</a></li>
<li class="toctree-l1"><a class="reference internal" href="tttr_objects.html#images">Images</a></li>
<li class="toctree-l1"><a class="reference internal" href="header_data.html">TTTR Header</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="applications.html">Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="references.html">References</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  <li><a href="applications.html">Applications</a><ul>
      <li>Previous: <a href="single_molecule.html" title="previous chapter">Single Molecule</a></li>
      <li>Next: <a href="imaging_analyzing_clsm_marker_leica_sp8.html" title="next chapter">Analyzing CLSM marker (Leica SP8)</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Thomas-Otavio Peulen.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.5</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/imaging.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>